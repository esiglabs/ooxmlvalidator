{"version":3,"sources":["../src/index.js"],"names":["extractTimestamp","signedXml","UnsignedProperties","sigTimeStamp","UnsignedSignatureProperties","items","forEach","item","localName","encTimeStamp","EncapsulatedTimeStamp","asn1","Value","buffer","contentInfo","schema","result","ex","validationData","GetElement","certEls","getElementsByTagNameNS","certificates","i","length","pem","textContent","certDer","cert","push","loadContentTypes","zip","Promise","resolve","then","file","async","xmlDoc","cont","types","getElementsByTagName","undefined","defaults","overrides","defaultEls","Array","prototype","slice","call","extension","el","getAttribute","contentType","overrideEls","part","getContentType","filename","contentTypes","override","split","pop","def","validateFile","hashAlgo","hash","transforms","crypto","digest","doc","trans","name","relsEl","rels","finalRels","id","rel","type","data","ids","indexOf","parentNode","removeChild","hasAttributeNS","setAttributeNS","sort","a","b","leftId","rightId","appendChild","transform","LoadInnerXml","GetOutput","toString","tempBuffer","ArrayBuffer","view","Uint8Array","charCodeAt","view1","view2","res","validateSig","num","trustedSigningCAs","trustedTimestampingCAs","sigInfo","sequence","tsToken","xmlSig","LoadXml","signature","KeyInfo","X509CertificateList","simpl","Verify","catch","sigVerified","unsignedSigProps","certBundle","EncapsulatedX509Certificates","rawCert","packageObject","obj","refs","checkList","err","uri","ref","n","params","substring","n2","param","key","algorithm","CreateHashAlgorithm","hashAlgorithm","b64Hash","transformEls","transformEl","childNodes","ooxmlns","transformData","idEls","j","idTypes","all","map","entry","hashVerified","reduce","truststore","signerVerified","status","hasTS","tsCertBundle","tsSigned","content","XmlSignature","GetChild","sigValueCanon","replace","verify","signer","checkChain","extendedMode","tsVerified","signatureVerified","tsCert","signerCertificate","e","tsCertVerified","OOXMLValidator","validationInfo","fileContents","addTrustStore","removeTrustStore","isValid","sigs","Object","keys","files","filter","match","Error","isSigned","signatures"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * OOXML Validator module\n *\n * By Fotis Loukos <me@fotisl.com>\n * @module ooxmlvalidator\n */\nimport { Certificate, ContentInfo, SignedData, getCrypto } from 'pkijs';\nimport { fromBER } from 'asn1js';\nimport { Parse as XmlCoreParse } from 'xml-core';\nimport { CryptoConfig, XmlDsigC14NTransform } from 'xmldsigjs';\nimport { Parse as XadesjsParse, SignedXml } from 'xadesjs';\nimport { fromBase64, stringToArrayBuffer } from 'pvutils';\nimport { loadAsync } from 'jszip';\nimport { SignatureInfo, TrustStoreList, ValidationInfo, verifyChain } from 'eslutils';\nimport './webcrypto';\n\n/**\n * Timestamp token and associated certificates.\n * @typedef {Object} TimestampTokenCerts\n * @property {pkijs.ContentInfo} contentInfo - The timestamp token.\n * @property {Array<pkijs.Certificate>} certificates - The associated\n * certificates.\n */\n\n/**\n * Hashing algorithm specification.\n * @typedef {Object} HashAlgorithm\n * @property {string} name - The name of the algorithm.\n */\n\n/**\n * XML transformation specification.\n * @typedef {Object} Transformation\n * @property {string} name - The type of the transformation\n * (relationshiptransform or c14n).\n * @property {Object} data - Associated data based on the transformation.\n */\n\n/**\n * Default content type for a specific extension.\n * @typedef {Object} Default\n * @property {string} extension - The extension of the file.\n * @property {string} contentType - The content type.\n */\n\n/**\n * Content type override for a specific file.\n * @typedef {Object} Override\n * @property {string} part - The name of the file.\n * @property {string} contentType - The content type.\n */\n\n/**\n * Content types contained in the OOXML file.\n * @typedef {Object} ContentTypes\n * @property {Array<Default>} defaults - The default content types based on the\n * extension of the file.\n * @property {Array<Override>} overrides - Overrides for specific files.\n */\n\n/**\n * Extract the timestamp from a signature.\n * @param {SignedXml} signedXml - The signed XML.\n * @return {TimestampTokenCerts} The signature and signing cert, or null if no\n * timestamp exists.\n */\nfunction extractTimestamp(signedXml) {\n  if(!('UnsignedProperties' in signedXml) ||\n    !('UnsignedSignatureProperties' in signedXml.UnsignedProperties))\n    return null;\n\n  let sigTimeStamp;\n  signedXml.UnsignedProperties.UnsignedSignatureProperties.items\n    .forEach(item => {\n      if(item.localName === 'SignatureTimeStamp')\n        sigTimeStamp = item;\n    });\n\n  if(typeof sigTimeStamp === 'undefined')\n    return null;\n\n  if(!('EncapsulatedTimeStamp' in sigTimeStamp))\n    return null;\n\n  let encTimeStamp;\n  sigTimeStamp.EncapsulatedTimeStamp.items.forEach(item => {\n    if(item.localName === 'EncapsulatedTimeStamp')\n      encTimeStamp = item;\n  });\n\n  if(typeof encTimeStamp === 'undefined')\n    return null;\n\n  const asn1 = fromBER(encTimeStamp.Value.buffer);\n\n  let contentInfo;\n  try {\n    contentInfo = new ContentInfo({ schema: asn1.result });\n  } catch(ex) {\n    return null;\n  }\n\n  let validationData;\n  try {\n    validationData = signedXml.UnsignedProperties.UnsignedSignatureProperties\n      .GetElement('TimeStampValidationData')\n  } catch(ex) {\n    return null;\n  }\n\n  const certEls = validationData.getElementsByTagNameNS(\n    'http://uri.etsi.org/01903/v1.3.2#', 'EncapsulatedX509Certificate');\n  const certificates = [];\n  for(let i = 0; i < certEls.length; i++) {\n    const pem = certEls[i].textContent;\n    const certDer = stringToArrayBuffer(fromBase64(pem));\n    const asn1 = fromBER(certDer);\n    const cert = new Certificate({ schema: asn1.result });\n    certificates.push(cert);\n  }\n\n  return {\n    contentInfo,\n    certificates\n  };\n}\n\n/**\n * Load and parse content types.\n * @param {JSZip} zip - The OOXML file.\n * @return {Promise<ContentTypes>} A promise that is resolved with an object\n * containing all the necessary content type information.\n */\nfunction loadContentTypes(zip) {\n  return Promise.resolve().then(() => {\n    return zip.file('[Content_Types].xml').async('string');\n  }).then(cont => {\n    const xmlDoc = XmlCoreParse(cont);\n    const types = xmlDoc.getElementsByTagName('Types');\n\n    if(types.length !== 1)\n      return undefined;\n\n    const defaults = [];\n    const overrides = [];\n\n    const defaultEls = Array.prototype.slice.call(\n      types[0].getElementsByTagName('Default'));\n    defaultEls.forEach(el => {\n      defaults.push({\n        extension: el.getAttribute('Extension'),\n        contentType: el.getAttribute('ContentType')\n      });\n    });\n\n    const overrideEls = Array.prototype.slice.call(\n      types[0].getElementsByTagName('Override'));\n    overrideEls.forEach(el => {\n      overrides.push({\n        part: el.getAttribute('PartName'),\n        contentType: el.getAttribute('ContentType')\n      });\n    });\n\n    return {\n      defaults,\n      overrides\n    }\n  });\n}\n\n/**\n * Find the content type of a file.\n * @param {string} filename - The filename.\n * @param {ContentTypes} contentTypes - The OOXML content types as a\n * ContentTypes object.\n * @return {string} The filename's content type.\n */\nfunction getContentType(filename, contentTypes) {\n  let contentType;\n\n  contentTypes.overrides.forEach(override => {\n    if(override.part === filename)\n      contentType = override.contentType;\n  });\n\n  if(typeof contentType !== 'undefined')\n    return contentType;\n\n  const extension = filename.split('.').pop();\n\n  contentTypes.defaults.forEach(def => {\n    if(def.extension === extension)\n      contentType = def.contentType;\n  });\n\n  return contentType;\n}\n\n/**\n * Validate the hash of a file.\n * @param {JSZip} zip - The OOXML file.\n * @param {string} filename - The filename.\n * @param {HashAlgorithm} hashAlgo - The hash algorithm.\n * @param {ArrayBuffer} hash - The expected hash of the file.\n * @param {Array<Transformation>} transforms - The transforms to be applied to\n * the file.\n * @return {Promise<boolean>} A promise that is resolved with true if the\n * hash has validated, otherwise false.\n */\nfunction validateFile(zip, filename, hashAlgo, hash, transforms) {\n  return Promise.resolve().then(() => {\n    if(filename[0] === '/')\n      filename = filename.slice(1);\n\n    if(transforms.length === 0)\n      return zip.file(filename).async('uint8array');\n    else\n      return zip.file(filename).async('string');\n  }).then(cont => {\n    const crypto = getCrypto();\n\n    if(transforms.length === 0)\n      return crypto.digest(hashAlgo, cont);\n\n    const xmlDoc = XmlCoreParse(cont, 'application/xml');\n    let doc;\n\n    transforms.forEach(trans => {\n      if(trans.name === 'relationshiptransform') {\n        const relsEl = xmlDoc.getElementsByTagName('Relationships')[0];\n        const rels = Array.prototype.slice.call(\n          relsEl.getElementsByTagName('Relationship'));\n\n        const finalRels = [];\n        rels.forEach(rel => {\n          const id = rel.getAttribute('Id');\n          const type = rel.getAttribute('Type');\n\n          if((trans.data.ids.indexOf(id) === -1) &&\n            (trans.data.types.indexOf(type) === -1)) {\n            rel.parentNode.removeChild(rel);\n          } else {\n            // We must add TargetMode with the default value Internal if no\n            // such attribute exists\n            if(!rel.hasAttributeNS(undefined, 'TargetMode'))\n              rel.setAttributeNS(undefined, 'TargetMode', 'Internal');\n            finalRels.push(rel);\n          }\n        });\n\n        finalRels.sort((a, b) => {\n          const leftId = a.getAttribute('Id');\n          const rightId = b.getAttribute('Id');\n\n          if(leftId === rightId)\n            return 0;\n          if(leftId < rightId)\n            return -1;\n          return 1;\n        });\n\n        finalRels.forEach(rel => relsEl.appendChild(rel));\n      } else if(trans.name === 'c14n') {\n        // We assume c14n is always the last transformation.\n        const transform = new XmlDsigC14NTransform();\n        transform.LoadInnerXml(xmlDoc);\n        doc = transform.GetOutput();\n      }\n    });\n\n    if(typeof doc === 'undefined')\n      doc = xmlDoc.toString();\n\n    const tempBuffer = new ArrayBuffer(doc.length);\n    const view = new Uint8Array(tempBuffer);\n\n    for(let i = 0; i < doc.length; i++)\n      view[i] = doc.charCodeAt(i);\n\n    return crypto.digest(hashAlgo, tempBuffer);\n  }).then(res => {\n    const view1 = new Uint8Array(hash);\n    const view2 = new Uint8Array(res);\n\n    if(view1.length !== view2.length)\n      return false;\n\n    for(let i = 0; i < view1.length; i++) {\n      if(view1[i] !== view2[i])\n        return false;\n    }\n\n    return true;\n  });\n}\n\n/**\n * Validate a single signature.\n * @param {JSZip} zip - The OOXML file.\n * @param {integer} num - The number of the signature.\n * @param {eslutils.TrustStoreList} trustedSigningCAs - Trusted document\n * signing CAs.\n * @param {eslutils.TrustStoreList} trustedTimestampingCAs - Trusted document\n * timestamping CAs.\n * @return {Promise<eslutils.SignatureInfo>} A promise that is resolved with a\n * SignatureInfo object containing information about the signature.\n */\nfunction validateSig(zip, num, trustedSigningCAs, trustedTimestampingCAs) {\n  const sigInfo = new SignatureInfo(num);\n  let sequence = Promise.resolve();\n  let xmlDoc, signedXml, tsToken, contentTypes;\n\n  sequence = sequence.then(() => loadContentTypes(zip)).then(result => {\n    contentTypes = result;\n  }).then(() => {\n    return zip.file(`_xmlsignatures/sig${num}.xml`).async('string');\n  }).then(cont => {\n    xmlDoc = XadesjsParse(cont, 'application/xml');\n    const xmlSig = xmlDoc.getElementsByTagNameNS(\n      'http://www.w3.org/2000/09/xmldsig#', 'Signature');\n    signedXml = new SignedXml(xmlDoc);\n    signedXml.LoadXml(xmlSig[0]);\n\n    sigInfo.cert = signedXml.signature.KeyInfo.items[0]\n      .X509CertificateList[0].simpl;\n\n    return signedXml.Verify();\n  }).then(res => {\n    return res;\n  }).catch(e => {\n    return false;\n  }).then(res => {\n    sigInfo.sigVerified = res;\n\n    try {\n      const unsignedSigProps = signedXml.UnsignedProperties.UnsignedSignatureProperties;\n      unsignedSigProps.items.forEach(item => {\n        if(item.localName !== 'CertificateValues')\n          return;\n\n        sigInfo.certBundle = [];\n        if('EncapsulatedX509Certificates' in item) {\n          item.EncapsulatedX509Certificates.items.forEach(rawCert => {\n            const asn1 = fromBER(rawCert.Value.buffer);\n            sigInfo.certBundle.push(new Certificate({ schema: asn1.result }));\n          });\n        }\n      });\n    } catch(ex) {\n      // If there are no certs, ignore it.\n    }\n\n    let packageObject;\n    Array.prototype.slice.call(xmlDoc.getElementsByTagName('Object'))\n      .forEach(obj => {\n        if(obj.getAttribute('Id') === 'idPackageObject')\n          packageObject = obj;\n      });\n\n    if(typeof packageObject === 'undefined')\n      return [ false ];\n\n    const refs = Array.prototype.slice.call(\n      packageObject.getElementsByTagName('Reference'));\n    const checkList = [];\n    let err = false;\n    refs.forEach(ref => {\n      if(err === true)\n        return;\n      let uri = ref.getAttribute('URI');\n      const n = uri.indexOf('?');\n      let contentType;\n\n      if(n !== -1) {\n        const params = uri.substring(n + 1);\n        uri = uri.substring(0, n);\n        params.split('&').forEach(param => {\n          const n2 = param.indexOf('=');\n          const key = param.substring(0, n2);\n          if(key === 'ContentType')\n            contentType = param.substring(n2 + 1);\n        });\n      } else {\n        err = true;\n        return;\n      }\n\n      if(typeof contentType === 'undefined') {\n        err = true;\n        return;\n      }\n\n      if(getContentType(uri, contentTypes) !== contentType) {\n        err = true;\n        return;\n      }\n\n      const algorithm = CryptoConfig.CreateHashAlgorithm(ref\n        .getElementsByTagName('DigestMethod')[0].getAttribute('Algorithm'))\n        .algorithm;\n\n      // We assume the same algorithm is used for all files\n      sigInfo.hashAlgorithm = algorithm.name;\n\n      const b64Hash = ref.getElementsByTagName('DigestValue')[0].textContent;\n      const hash = stringToArrayBuffer(fromBase64(b64Hash));\n\n      const transforms = [];\n      const transformEls = Array.prototype.slice.call(\n        ref.getElementsByTagName('Transforms'));\n      transformEls.forEach(transformEl => {\n        for(let i = 0; i < transformEl.childNodes.length; i++) {\n          const transform = transformEl.childNodes[i];\n          const ooxmlns = 'http://schemas.openxmlformats.org/package/2006';\n          if(transform.getAttribute('Algorithm') ===\n            `${ooxmlns}/RelationshipTransform`) {\n            const transformData = {\n              ids: [],\n              types: []\n            };\n\n            const idEls = transform.getElementsByTagNameNS(\n              `${ooxmlns}/digital-signature`, 'RelationshipReference');\n            for(let j = 0; j < idEls.length; j++)\n              transformData.ids.push(idEls[j].getAttribute('SourceId'));\n\n            const idTypes = transform.getElementsByTagNameNS(\n              `${ooxmlns}/digital-signature`, 'RelationshipsGroupReference');\n            for(let j = 0; j < idTypes.length; j++)\n              transformData.types.push(idTypes[j].getAttribute('SourceType'));\n\n            transforms.push({\n              name: 'relationshiptransform',\n              data: transformData\n            });\n          } else if(transform.getAttribute('Algorithm') ===\n            'http://www.w3.org/TR/2001/REC-xml-c14n-20010315') {\n            transforms.push({\n              name: 'c14n'\n            });\n          } else {\n            err = true;\n          }\n        }\n      });\n\n      checkList.push({\n        uri,\n        algorithm,\n        hash,\n        transforms\n      });\n    });\n    if(err === true)\n      return [ false ];\n\n    return Promise.all(checkList.map(entry =>\n      validateFile(zip, entry.uri, entry.algorithm, entry.hash,\n        entry.transforms)));\n  }).then(res => {\n    sigInfo.hashVerified = res.reduce((a, b) => a && b);\n  });\n\n  trustedSigningCAs.forEach(truststore => {\n    sequence = sequence.then(() => verifyChain(sigInfo.cert, [],\n      truststore.certificates)).then(result => {\n      sigInfo.signerVerified.push({\n        name: truststore.name,\n        status: result\n      });\n    });\n  });\n\n  sequence = sequence.then(() => {\n    tsToken = extractTimestamp(signedXml);\n    if(tsToken !== null) {\n      sigInfo.hasTS = true;\n      sigInfo.tsCertBundle = tsToken.certificates.slice();\n\n      const tsSigned = new SignedData({\n        schema: tsToken.contentInfo.content\n      });\n\n      const transform = new XmlDsigC14NTransform();\n      transform.LoadInnerXml(signedXml.XmlSignature.GetChild('SignatureValue'));\n      let sigValueCanon = transform.GetOutput();\n      // According to https://www.w3.org/TR/REC-xml/#sec-line-ends, parsers\n      // should convert any EOL to \\n. This fixes a bug in an older xmldsig\n      // version.\n      sigValueCanon = sigValueCanon.replace(/&#xD;/g, '');\n\n      return tsSigned.verify({\n        signer: 0,\n        data: stringToArrayBuffer(sigValueCanon),\n        checkChain: false,\n        extendedMode: true\n      });\n    } else {\n      return false;\n    }\n  }).then(result => {\n    if(tsToken !== null) {\n      sigInfo.tsVerified = result.signatureVerified;\n      sigInfo.tsCert = result.signerCertificate;\n    }\n  }).catch(e => {\n    if(tsToken !== null) {\n      sigInfo.tsVerified = false;\n      sigInfo.tsCert = e.signerCertificate;\n    }\n  });\n\n  trustedTimestampingCAs.forEach(truststore => {\n    sequence = sequence.then(() => {\n      if(tsToken !== null)\n        return verifyChain(sigInfo.tsCert, tsToken.certificates,\n          truststore.certificates);\n    }).then(result => {\n      if(tsToken !== null) {\n        sigInfo.tsCertVerified.push({\n          name: truststore.name,\n          status: result\n        });\n      }\n    });\n  });\n\n  return sequence.then(() => sigInfo);\n}\n\n/**\n * OOXML Validator class\n */\nexport class OOXMLValidator {\n  /**\n   * Load an OOXML file from a buffer.\n   * @param {ArrayBuffer} buffer - The buffer containing the OOXML file.\n   */\n  constructor(buffer) {\n    /**\n     * @type {eslutils.TrustStoreList}\n     * @description Trusted document signing CAs.\n     */\n    this.trustedSigningCAs = new TrustStoreList();\n    /**\n     * @type {eslutils.TrustStoreList}\n     * @description Trusted document timestamping CAs.\n     */\n    this.trustedTimestampingCAs = new TrustStoreList();\n    /**\n     * @type {eslutils.ValidationInfo}\n     * @description A ValidationInfo object holding the validation results.\n     */\n    this.validationInfo = new ValidationInfo();\n    /**\n     * @type {ArrayBuffer}\n     * @description The contents of the OOXML file.\n     */\n    this.fileContents = buffer;\n    /**\n     * @type {JSZip}\n     * @description The file as a zip structure.\n     */\n    this.zip = null;\n  }\n\n  /**\n   * Add a trust store to the document signing trust stores.\n   * @param {TrustStore} truststore - The trust store to add.\n   */\n  addSigningTruststore(truststore) {\n    this.trustedSigningCAs.addTrustStore(truststore);\n  }\n\n  /**\n   * Remove a trust store from the document signing trust stores by name.\n   * @param {string} name - The name of the trust store to remove.\n   */\n  removeSigningTruststore(name) {\n    this.trustedSigningCAs.removeTrustStore(name);\n  }\n\n  /**\n   * Add a trust store to the timestamping trust stores.\n   * @param {TrustStore} truststore - The trust store to add.\n   */\n  addTimestampingTruststore(truststore) {\n    this.trustedTimestampingCAs.addTrustStore(truststore);\n  }\n\n  /**\n   * Remove a trust store from the document signing trust stores by name.\n   * @param {string} name - The name of the trust store to remove.\n   */\n  removeTimestampingTruststore(name) {\n    this.trustedTimestampingCAs.removeTrustStore(name);\n  }\n\n  /**\n   * Validate the OOXML file.\n   * @return {Promise<eslutils.ValidationInfo>} A promise that is resolved with\n   * a ValidationInfo object containing the validation results.\n   */\n  validate() {\n    let sequence = Promise.resolve();\n\n    sequence = sequence.then(() => loadAsync(this.fileContents))\n      .then(zip => {\n        this.zip = zip;\n        this.validationInfo.isValid = true;\n\n        const sigs = Object.keys(zip.files).filter(name =>\n          name.match(/_xmlsignatures\\/sig[0-9]+.xml/)).map(name =>\n          name.replace('_xmlsignatures/sig', '').replace('.xml', ''));\n        if(sigs.length === 0)\n          throw new Error('Unsigned OOXML file');\n\n        this.validationInfo.isSigned = true;\n\n        return Promise.all(sigs.map(num => validateSig(zip, num,\n          this.trustedSigningCAs, this.trustedTimestampingCAs)));\n      }, e => {\n        throw new Error('Invalid OOXML file');\n      }).then(res => {\n        this.validationInfo.signatures = res.slice();\n      }).catch(() => {});\n\n    return sequence.then(() => this.validationInfo);\n  }\n}\n"]}