{"version":3,"sources":["../src/index.js"],"names":["pkijs","asn1js","xmlcore","xmldsigjs","xadesjs","pvutils","jszip","verifyChain","certificate","chain","trustedCAs","Promise","resolve","then","certificateChainEngine","CertificateChainValidationEngine","certs","trustedCerts","filter","cert","push","verify","result","extractTimestamp","signedXml","UnsignedProperties","sigTimeStamp","UnsignedSignatureProperties","items","forEach","item","localName","encTimeStamp","EncapsulatedTimeStamp","asn1","fromBER","Value","buffer","contentInfo","ContentInfo","schema","ex","validationData","GetElement","certEls","getElementsByTagNameNS","certificates","i","length","pem","textContent","certDer","stringToArrayBuffer","fromBase64","Certificate","loadContentTypes","zip","file","async","xmlDoc","Parse","cont","types","getElementsByTagName","undefined","defaults","overrides","defaultEls","Array","prototype","slice","call","extension","el","getAttribute","contentType","overrideEls","part","getContentType","filename","contentTypes","override","split","pop","def","validateFile","hashAlgo","hash","transforms","crypto","getCrypto","digest","doc","trans","name","relsEl","rels","finalRels","id","rel","type","data","ids","indexOf","parentNode","removeChild","hasAttributeNS","setAttributeNS","sort","a","b","leftId","rightId","appendChild","transform","XmlDsigC14NTransform","LoadInnerXml","GetOutput","toString","tempBuffer","ArrayBuffer","view","Uint8Array","charCodeAt","view1","view2","res","validateSig","num","trustedSigningCAs","trustedTimestampingCAs","sigInfo","SignatureInfo","sequence","tsToken","xmlSig","SignedXml","LoadXml","signature","KeyInfo","X509CertificateList","simpl","Verify","catch","sigVerified","packageObject","obj","refs","checkList","err","uri","ref","n","params","substring","n2","param","key","algorithm","CryptoConfig","CreateHashAlgorithm","hashAlgorithm","b64Hash","transformEls","transformEl","childNodes","ooxmlns","transformData","idEls","j","idTypes","all","map","entry","hashVerified","reduce","truststore","signerVerified","status","hasTS","tsSigned","SignedData","content","XmlSignature","GetChild","sigValueCanon","replace","signer","checkChain","extendedMode","tsVerified","signatureVerified","tsCert","signerCertificate","e","tsCertVerified","ValidationInfo","isValid","isSigned","signatures","signingTruststore","timestampingTruststore","verified","isSignersVerified","OOXMLValidator","ooxmlInfo","fileContents","idx","splice","loadAsync","sigs","Object","keys","files","match","Error"],"mappings":"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","file":"index.js","sourcesContent":["/**\n * OOXML Validator module\n *\n * By Fotis Loukos <me@fotisl.com>\n * @module ooxmlvalidator\n */\nimport * as pkijs from 'pkijs';\nimport * as asn1js from 'asn1js';\nimport * as xmlcore from 'xml-core';\nimport * as xmldsigjs from 'xmldsigjs';\nimport * as xadesjs from 'xadesjs';\nimport * as pvutils from 'pvutils';\nimport * as jszip from 'jszip';\nimport './webcrypto';\n\n/**\n  * A trust store.\n  * @typedef {Object} TrustStore\n  * @property {string} name - The name of the trust store.\n  * @property {Array<pkijs.Certificate>} certificates - All the certificates\n  * contained in the trust store.\n  */\n\n/**\n * Trust store verification status.\n * @typedef {Object} TrustStoreStatus\n * @property {string} name - The name of the trust store.\n * @property {boolean} status - True if the certificate chains to this trust\n * store, false otherwise.\n */\n\n/**\n * Timestamp token and associated certificates.\n * @typedef {Object} TimestampTokenCerts\n * @property {pkijs.ContentInfo} contentInfo - The timestamp token.\n * @property {Array<pkijs.Certificate>} certificates - The associated\n * certificates.\n */\n\n/**\n * Hashing algorithm specification.\n * @typedef {Object} HashAlgorithm\n * @property {string} name - The name of the algorithm.\n */\n\n/**\n * XML transformation specification.\n * @typedef {Object} Transformation\n * @property {string} name - The type of the transformation\n * (relationshiptransform or c14n).\n * @property {Object} data - Associated data based on the transformation.\n */\n\n/**\n * Default content type for a specific extension.\n * @typedef {Object} Default\n * @property {string} extension - The extension of the file.\n * @property {string} contentType - The content type.\n */\n\n/**\n * Content type override for a specific file.\n * @typedef {Object} Override\n * @property {string} part - The name of the file.\n * @property {string} contentType - The content type.\n */\n\n/**\n * Content types contained in the OOXML file.\n * @typedef {Object} ContentTypes\n * @property {Array<Default>} defaults - The default content types based on the\n * extension of the file.\n * @property {Array<Override>} overrides - Overrides for specific files.\n */\n\n/**\n * Verify if a certificate chains to some trusted CAs.\n * @param {pkijs.Certificate} certificate - The certificate that will be\n * checked.\n * @param {Array<pkijs.Certificate>} chain - Additional certificates in the\n * chain.\n * @param {Array<pkijs.Certificate>} trustedCAs - The trusted CAs\n * @return {Promise<boolean>} A promise that is resolved with a boolean value\n * stating if the certificate was verified or not.\n */\nfunction verifyChain(certificate, chain, trustedCAs) {\n  if(certificate === null)\n    return Promise.resolve(false);\n\n  return Promise.resolve().then(() => {\n    const certificateChainEngine = new pkijs.CertificateChainValidationEngine({\n      certs: chain,\n      trustedCerts: trustedCAs.filter(cert => typeof cert !== 'undefined')\n    });\n    certificateChainEngine.certs.push(certificate);\n\n    return certificateChainEngine.verify();\n  }).then(result => {\n    return result.result;\n  }, result => {\n    return false;\n  });\n}\n\n/**\n * Extract the timestamp from a signature.\n * @param {SignedXml} signedXml - The signed XML.\n * @return {TimestampTokenCerts} The signature and signing cert, or null if no\n * timestamp exists.\n */\nfunction extractTimestamp(signedXml) {\n  if(!('UnsignedProperties' in signedXml) ||\n    !('UnsignedSignatureProperties' in signedXml.UnsignedProperties))\n    return null\n\n  let sigTimeStamp;\n  signedXml.UnsignedProperties.UnsignedSignatureProperties.items\n    .forEach(item => {\n      if(item.localName === 'SignatureTimeStamp')\n        sigTimeStamp = item;\n    });\n\n  if(typeof sigTimeStamp === 'undefined')\n    return null;\n\n  if(!('EncapsulatedTimeStamp' in sigTimeStamp))\n    return null;\n\n  let encTimeStamp;\n  sigTimeStamp.EncapsulatedTimeStamp.items.forEach(item => {\n    if(item.localName === 'EncapsulatedTimeStamp')\n      encTimeStamp = item;\n  });\n\n  if(typeof encTimeStamp === 'undefined')\n    return null;\n\n  const asn1 = asn1js.fromBER(encTimeStamp.Value.buffer);\n\n  let contentInfo;\n  try {\n    contentInfo = new pkijs.ContentInfo({ schema: asn1.result });\n  } catch(ex) {\n    return null;\n  }\n\n  let validationData;\n  try {\n    validationData = signedXml.UnsignedProperties.UnsignedSignatureProperties\n      .GetElement('TimeStampValidationData')\n  } catch(ex) {\n    return null;\n  }\n\n  const certEls = validationData.getElementsByTagNameNS(\n    'http://uri.etsi.org/01903/v1.3.2#', 'EncapsulatedX509Certificate');\n  const certificates = [];\n  for(let i = 0; i < certEls.length; i++) {\n    const pem = certEls[i].textContent;\n    const certDer = pvutils.stringToArrayBuffer(pvutils.fromBase64(pem));\n    const asn1 = asn1js.fromBER(certDer);\n    const cert = new pkijs.Certificate({ schema: asn1.result });\n    certificates.push(cert);\n  }\n\n  return {\n    contentInfo,\n    certificates\n  };\n}\n\n/**\n * Load and parse content types.\n * @param {JSZip} zip - The OOXML file.\n * @return {Promise<ContentTypes>} A promise that is resolved with an object\n * containing all the necessary content type information.\n */\nfunction loadContentTypes(zip) {\n  return Promise.resolve().then(() => {\n    return zip.file('[Content_Types].xml').async('string');\n  }).then(cont => {\n    const xmlDoc = xmlcore.Parse(cont);\n    const types = xmlDoc.getElementsByTagName('Types');\n\n    if(types.length !== 1)\n      return undefined;\n\n    const defaults = [];\n    const overrides = [];\n\n    const defaultEls = Array.prototype.slice.call(\n      types[0].getElementsByTagName('Default'));\n    defaultEls.forEach(el => {\n      defaults.push({\n        extension: el.getAttribute('Extension'),\n        contentType: el.getAttribute('ContentType')\n      });\n    });\n\n    const overrideEls = Array.prototype.slice.call(\n      types[0].getElementsByTagName('Override'));\n    overrideEls.forEach(el => {\n      overrides.push({\n        part: el.getAttribute('PartName'),\n        contentType: el.getAttribute('ContentType')\n      });\n    });\n\n    return {\n      defaults,\n      overrides\n    }\n  });\n}\n\n/**\n * Find the content type of a file.\n * @param {string} filename - The filename.\n * @param {ContentTypes} contentTypes - The OOXML content types as a\n * ContentTypes object.\n * @return {string} The filename's content type.\n */\nfunction getContentType(filename, contentTypes) {\n  let contentType;\n\n  contentTypes.overrides.forEach(override => {\n    if(override.part === filename)\n      contentType = override.contentType;\n  });\n\n  if(typeof contentType !== 'undefined')\n    return contentType;\n\n  const extension = filename.split('.').pop();\n\n  contentTypes.defaults.forEach(def => {\n    if(def.extension === extension)\n      contentType = def.contentType;\n  });\n\n  return contentType;\n}\n\n/**\n * Validate the hash of a file.\n * @param {JSZip} zip - The OOXML file.\n * @param {string} filename - The filename.\n * @param {HashAlgorithm} hashAlgo - The hash algorithm.\n * @param {ArrayBuffer} hash - The expected hash of the file.\n * @param {Array<Transformation>} transforms - The transforms to be applied to\n * the file.\n * @return {Promise<boolean>} A promise that is resolved with true if the\n * hash has validated, otherwise false.\n */\nfunction validateFile(zip, filename, hashAlgo, hash, transforms) {\n  return Promise.resolve().then(() => {\n    if(filename[0] === '/')\n      filename = filename.slice(1);\n\n    if(transforms.length === 0)\n      return zip.file(filename).async('uint8array');\n    else\n      return zip.file(filename).async('string');\n  }).then(cont => {\n    const crypto = pkijs.getCrypto();\n\n    if(transforms.length === 0)\n      return crypto.digest(hashAlgo, cont);\n\n    const xmlDoc = xmlcore.Parse(cont, 'application/xml');\n    let doc;\n\n    transforms.forEach(trans => {\n      if(trans.name === 'relationshiptransform') {\n        const relsEl = xmlDoc.getElementsByTagName('Relationships')[0];\n        const rels = Array.prototype.slice.call(\n          relsEl.getElementsByTagName('Relationship'));\n\n        const finalRels = [];\n        rels.forEach(rel => {\n          const id = rel.getAttribute('Id');\n          const type = rel.getAttribute('Type');\n\n          if((trans.data.ids.indexOf(id) === -1) &&\n            (trans.data.types.indexOf(type) === -1)) {\n            rel.parentNode.removeChild(rel);\n          } else {\n            // We must add TargetMode with the default value Internal if no\n            // such attribute exists\n            if(!rel.hasAttributeNS(undefined, 'TargetMode'))\n              rel.setAttributeNS(undefined, 'TargetMode', 'Internal');\n            finalRels.push(rel);\n          }\n        });\n\n        finalRels.sort((a, b) => {\n          const leftId = a.getAttribute('Id');\n          const rightId = b.getAttribute('Id');\n\n          if(leftId === rightId)\n            return 0;\n          if(leftId < rightId)\n            return -1;\n          return 1;\n        });\n\n        finalRels.forEach(rel => relsEl.appendChild(rel));\n      } else if(trans.name === 'c14n') {\n        // We assume c14n is always the last transformation.\n        const transform = new xmldsigjs.XmlDsigC14NTransform();\n        transform.LoadInnerXml(xmlDoc);\n        doc = transform.GetOutput();\n      }\n    });\n\n    if(typeof doc === 'undefined')\n      doc = xmlDoc.toString();\n\n    const tempBuffer = new ArrayBuffer(doc.length);\n    const view = new Uint8Array(tempBuffer);\n\n    for(let i = 0; i < doc.length; i++)\n      view[i] = doc.charCodeAt(i);\n\n    return crypto.digest(hashAlgo, tempBuffer);\n  }).then(res => {\n    const view1 = new Uint8Array(hash);\n    const view2 = new Uint8Array(res);\n\n    if(view1.length !== view2.length)\n      return false;\n\n    for(let i = 0; i < view1.length; i++) {\n      if(view1[i] !== view2[i])\n        return false;\n    }\n\n    return true;\n  });\n}\n\n/**\n * Validate a single signature.\n * @param {JSZip} zip - The OOXML file.\n * @param {integer} num - The number of the signature.\n * @param {Array<TrustStore>} trustedSigningCAs - Trusted document signing CAs.\n * @param {Array<TrustStore>} trustedTimestampingCAs - Trusted document\n * timestamping CAs.\n * @return {Promise<SignatureInfo>} A promise that is resolved with a\n * SignatureInfo object containing information about the signature.\n */\nfunction validateSig(zip, num, trustedSigningCAs, trustedTimestampingCAs) {\n  const sigInfo = new SignatureInfo(num);\n  let sequence = Promise.resolve();\n  let xmlDoc, signedXml, tsToken, contentTypes;\n\n  sequence = sequence.then(() => loadContentTypes(zip)).then(result => {\n    contentTypes = result;\n  }).then(() => {\n    return zip.file(`_xmlsignatures/sig${num}.xml`).async('string');\n  }).then(cont => {\n    xmlDoc = xadesjs.Parse(cont, 'application/xml');\n    const xmlSig = xmlDoc.getElementsByTagNameNS(\n      'http://www.w3.org/2000/09/xmldsig#', 'Signature');\n    signedXml = new xadesjs.SignedXml(xmlDoc);\n    signedXml.LoadXml(xmlSig[0]);\n\n    sigInfo.cert = signedXml.signature.KeyInfo.items[0]\n      .X509CertificateList[0].simpl;\n\n    return signedXml.Verify();\n  }).then(res => {\n    return res;\n  }).catch(e => {\n    return false;\n  }).then(res => {\n    sigInfo.sigVerified = res;\n\n    let packageObject;\n    Array.prototype.slice.call(xmlDoc.getElementsByTagName('Object'))\n      .forEach(obj => {\n        if(obj.getAttribute('Id') === 'idPackageObject')\n          packageObject = obj;\n      });\n\n    if(typeof packageObject === 'undefined')\n      return [ false ];\n\n    const refs = Array.prototype.slice.call(\n      packageObject.getElementsByTagName('Reference'));\n    const checkList = [];\n    let err = false;\n    refs.forEach(ref => {\n      if(err === true)\n        return;\n      let uri = ref.getAttribute('URI');\n      const n = uri.indexOf('?');\n      let contentType;\n\n      if(n !== -1) {\n        const params = uri.substring(n + 1);\n        uri = uri.substring(0, n);\n        params.split('&').forEach(param => {\n          const n2 = param.indexOf('=');\n          const key = param.substring(0, n2);\n          if(key === 'ContentType')\n            contentType = param.substring(n2 + 1);\n        });\n      } else {\n        err = true;\n        return;\n      }\n\n      if(typeof contentType === 'undefined') {\n        err = true;\n        return;\n      }\n\n      if(getContentType(uri, contentTypes) !== contentType) {\n        err = true;\n        return;\n      }\n\n      const algorithm = xmldsigjs.CryptoConfig.CreateHashAlgorithm(ref\n        .getElementsByTagName('DigestMethod')[0].getAttribute('Algorithm'))\n        .algorithm;\n\n      // We assume the same algorithm is used for all files\n      sigInfo.hashAlgorithm = algorithm.name;\n\n      const b64Hash = ref.getElementsByTagName('DigestValue')[0].textContent;\n      const hash = pvutils.stringToArrayBuffer(pvutils.fromBase64(b64Hash));\n\n      const transforms = [];\n      const transformEls = Array.prototype.slice.call(\n        ref.getElementsByTagName('Transforms'));\n      transformEls.forEach(transformEl => {\n        for(let i = 0; i < transformEl.childNodes.length; i++) {\n          const transform = transformEl.childNodes[i];\n          const ooxmlns = 'http://schemas.openxmlformats.org/package/2006';\n          if(transform.getAttribute('Algorithm') ===\n            `${ooxmlns}/RelationshipTransform`) {\n            const transformData = {\n              ids: [],\n              types: []\n            };\n\n            const idEls = transform.getElementsByTagNameNS(\n              `${ooxmlns}/digital-signature`, 'RelationshipReference');\n            for(let j = 0; j < idEls.length; j++)\n              transformData.ids.push(idEls[j].getAttribute('SourceId'));\n\n            const idTypes = transform.getElementsByTagNameNS(\n              `${ooxmlns}/digital-signature`, 'RelationshipsGroupReference');\n            for(let j = 0; j < idTypes.length; j++)\n              transformData.types.push(idTypes[j].getAttribute('SourceType'));\n\n            transforms.push({\n              name: 'relationshiptransform',\n              data: transformData\n            });\n          } else if(transform.getAttribute('Algorithm') ===\n            'http://www.w3.org/TR/2001/REC-xml-c14n-20010315') {\n            transforms.push({\n              name: 'c14n'\n            });\n          } else {\n            err = true;\n          }\n        }\n      });\n\n      checkList.push({\n        uri,\n        algorithm,\n        hash,\n        transforms\n      });\n    });\n    if(err === true)\n      return [ false ];\n\n    return Promise.all(checkList.map(entry =>\n      validateFile(zip, entry.uri, entry.algorithm, entry.hash,\n        entry.transforms)));\n  }).then(res => {\n    sigInfo.hashVerified = res.reduce((a, b) => a && b);\n  });\n\n  trustedSigningCAs.forEach(truststore => {\n    sequence = sequence.then(() => verifyChain(sigInfo.cert, [],\n      truststore.certificates)).then(result => {\n      sigInfo.signerVerified.push({\n        name: truststore.name,\n        status: result\n      });\n    });\n  });\n\n  sequence = sequence.then(() => {\n    tsToken = extractTimestamp(signedXml);\n    if(tsToken !== null) {\n      sigInfo.hasTS = true;\n\n      const tsSigned = new pkijs.SignedData({\n        schema: tsToken.contentInfo.content\n      });\n\n      const transform = new xmldsigjs.XmlDsigC14NTransform();\n      transform.LoadInnerXml(signedXml.XmlSignature.GetChild('SignatureValue'));\n      let sigValueCanon = transform.GetOutput();\n      // According to https://www.w3.org/TR/REC-xml/#sec-line-ends, parsers\n      // should convert any EOL to \\n. This fixes a bug in an older xmldsig\n      // version.\n      sigValueCanon = sigValueCanon.replace(/&#xD;/g, '');\n\n      return tsSigned.verify({\n        signer: 0,\n        data: pvutils.stringToArrayBuffer(sigValueCanon),\n        checkChain: false,\n        extendedMode: true\n      });\n    } else {\n      return false;\n    }\n  }).then(result => {\n    if(tsToken !== null) {\n      sigInfo.tsVerified = result.signatureVerified;\n      sigInfo.tsCert = result.signerCertificate;\n    }\n  }).catch(e => {\n    if(tsToken !== null) {\n      sigInfo.tsVerified = false;\n      sigInfo.tsCert = e.signerCertificate;\n    }\n  });\n\n  trustedTimestampingCAs.forEach(truststore => {\n    sequence = sequence.then(() => {\n      if(tsToken !== null)\n        return verifyChain(sigInfo.tsCert, [], truststore.certificates);\n    }).then(result => {\n      if(tsToken !== null) {\n        sigInfo.tsCertVerified.push({\n          name: truststore.name,\n          status: result\n        });\n      }\n    });\n  });\n\n  return sequence.then(() => sigInfo);\n}\n\n/**\n * Object validation information.\n */\nexport class ValidationInfo {\n  /**\n   * Generate an empty ValidationInfo object.\n   * @constructor\n   */\n  constructor() {\n    /**\n     * @type {boolean}\n     * @description A valid file.\n     */\n    this.isValid = false;\n    /**\n     * @type {boolean}\n     * @description A signed file.\n     */\n    this.isSigned = false;\n    /**\n     * @type {Array<SignatureInfo>}\n     * @description Validation information for all signatures.\n     */\n    this.signatures = [];\n  }\n\n  /**\n   * Check if all signatures have been verified.\n   */\n  get sigVerified() {\n    let verified = true;\n\n    this.signatures.forEach(sigInfo => {\n      verified &= sigInfo.sigVerified;\n    });\n\n    return verified;\n  }\n\n  /**\n   * Check if all hashes correspond to the signed data.\n   */\n  get hashVerified() {\n    let verified = true;\n\n    this.signatures.forEach(sigInfo => {\n      verified &= sigInfo.hashVerified;\n    });\n\n    return verified;\n  }\n\n  /**\n   * Check if all signers have been verified against a truststore.\n   * @param {string} signingTruststore - The name of the signing truststore.\n   * @param {string} timestampingTruststore - The name of the timestamping\n   * truststore.\n   * @return {boolean} True if the file was verified against both truststores,\n   * false otherwise.\n   */\n  isSignersVerified(signingTruststore, timestampingTruststore) {\n    let verified = true;\n\n    this.signatures.forEach(sigInfo => {\n      verified &= sigInfo.isSignersVerified(signingTruststore,\n        timestampingTruststore);\n    });\n\n    return verified;\n  }\n}\n\n/**\n * Single signature validation information.\n */\nexport class SignatureInfo {\n  /**\n   * Generate an empty SignatureInfo object.\n   * @param {Object} id - The signature's identifier.\n   * @constructor\n   */\n  constructor(id) {\n    /**\n     * @type {Object}\n     * @description An identifier for the signature.\n     */\n    this.id = id;\n    /**\n     * @type {boolean}\n     * @description Signed hash has been verified.\n     */\n    this.sigVerified = false;\n    /**\n     * @type {boolean}\n     * @description The hash corresponds to the signed data.\n     */\n    this.hashVerified = false;\n    /**\n     * @type {string}\n     * @description The algorithm that was used to hash the data.\n     */\n    this.hashAlgorithm = '';\n    /**\n     * @type {Array<TrustStoreStatus>}\n     * @description Signer certificate chains to a trusted signing CA.\n     */\n    this.signerVerified = [];\n    /**\n     * @type {boolean}\n     * @description A timestamped OOXML file.\n     */\n    this.hasTS = false;\n    /**\n     * @type {boolean}\n     * @description The timestamp has been verified.\n     */\n    this.tsVerified = false;\n    /**\n     * @type {Array<TrustStoreStatus>}\n     * @description The certificate of the timestamp chains to a trusted\n     * timestamping CA.\n     */\n    this.tsCertVerified = [];\n    /**\n     * @type {pkijs.Certificate}\n     * @description The signer's certificate.\n     */\n    this.cert = null;\n    /**\n     * @type {pkijs.Certificate}\n     * @description The timestamp authority's certificate.\n     */\n    this.tsCert = null;\n  }\n\n  /**\n   * Check if the file verified was a valid signed OOXML whose signature and\n   * signed hash have been verified.\n   */\n  get isValidSigned() {\n    return this.isValid & this.isSigned & this.sigVerified & this.hashVerified;\n  }\n\n  /**\n   * Check if the file verified was a valid signed and timestamped OOXML whose\n   * signature, signed hash and timestamp have been verified.\n   */\n  get isValidSignedTimestamped() {\n    return this.isValid & this.isSigned & this.sigVerified &\n      this.hashVerified & this.hasTS & this.tsVerified;\n  }\n\n  /**\n   * Check if the signer has been verified against a truststore. If the file is\n   * timestamped, then the timestamp signer will also be checked against another\n   * truststore.\n   * @param {string} signingTruststore - The name of the signing truststore.\n   * @param {string} timestampingTruststore - The name of the timestamping\n   * truststore.\n   * @return {boolean} True if the file was verified against both truststores,\n   * false otherwise.\n   */\n  isSignersVerified(signingTruststore, timestampingTruststore) {\n    if(!this.isValid || !this.isSigned)\n      return false;\n\n    let verified = false;\n    this.signerVerified.forEach(signer => {\n      if(signer.name === signingTruststore)\n        verified = signer.status;\n    });\n    if(verified === false)\n      return false;\n\n    if(this.hasTS) {\n      verified = false;\n      this.tsCertVerified.forEach(signer => {\n        if(signer.name === timestampingTruststore)\n          verified = signer.status;\n      });\n      if(verified === false)\n        return false;\n    }\n\n    return true;\n  }\n};\n\n/**\n * OOXML Validator class\n */\nexport class OOXMLValidator {\n  /**\n   * Load an OOXML file from a buffer.\n   * @param {ArrayBuffer} buffer - The buffer containing the OOXML file.\n   */\n  constructor(buffer) {\n    /**\n     * @type {Array<TrustStore>}\n     * @description Trusted document signing CAs.\n     */\n    this.trustedSigningCAs = [];\n    /**\n     * @type {Array<TrustStore>}\n     * @description Trusted document timestamping CAs.\n     */\n    this.trustedTimestampingCAs = [];\n    /**\n     * @type {ValidationInfo}\n     * @description A ValidationInfo object holding the validation results.\n     */\n    this.ooxmlInfo = new ValidationInfo();\n    /**\n     * @type {ArrayBuffer}\n     * @description The contents of the OOXML file.\n     */\n    this.fileContents = buffer;\n    /**\n     * @type {JSZip}\n     * @description The file as a zip structure.\n     */\n    this.zip = null;\n  }\n\n  /**\n   * Add a trust store to the document signing trust stores.\n   * @param {TrustStore} truststore - The trust store to add.\n   */\n  addSigningTruststore(truststore) {\n    this.trustedSigningCAs.push(truststore);\n  }\n\n  /**\n   * Remove a trust store from the document signing trust stores by name.\n   * @param {string} name - The name of the trust store to remove.\n   */\n  removeSigningTruststore(name) {\n    let idx;\n\n    for(idx = 0; idx < this.trustedSigningCAs.length; idx++) {\n      if(this.trustedSigningCAs[idx].name === name) {\n        this.trustedSigningCAs.splice(idx, 1);\n        idx--;\n      }\n    }\n  }\n\n  /**\n   * Add a trust store to the timestamping trust stores.\n   * @param {TrustStore} truststore - The trust store to add.\n   */\n  addTimestampingTruststore(truststore) {\n    this.trustedTimestampingCAs.push(truststore);\n  }\n\n  /**\n   * Remove a trust store from the document signing trust stores by name.\n   * @param {string} name - The name of the trust store to remove.\n   */\n  removeTimestampingTruststore(name) {\n    let idx;\n\n    for(idx = 0; idx < this.trustedTimestampingCAs.length; idx++) {\n      if(this.trustedTimestampingCAs[idx].name === name) {\n        this.trustedTimestampingCAs.splice(idx, 1);\n        idx--;\n      }\n    }\n  }\n\n  /**\n   * Validate the OOXML file.\n   * @return {Promise<ValidationInfo>} A promise that is resolved with an\n   * ValidationInfo object containing the validation results.\n   */\n  validate() {\n    let sequence = Promise.resolve();\n\n    sequence = sequence.then(() => jszip.loadAsync(this.fileContents))\n      .then(zip => {\n        this.zip = zip;\n        this.ooxmlInfo.isValid = true;\n\n        const sigs = Object.keys(zip.files).filter(name =>\n          name.match(/_xmlsignatures\\/sig[0-9]+.xml/)).map(name =>\n          name.replace('_xmlsignatures/sig', '').replace('.xml', ''));\n        if(sigs.length === 0)\n          throw new Error('Unsigned OOXML file');\n\n        this.ooxmlInfo.isSigned = true;\n\n        return Promise.all(sigs.map(num => validateSig(zip, num,\n          this.trustedSigningCAs, this.trustedTimestampingCAs)));\n      }, e => {\n        throw new Error('Invalid OOXML file');\n      }).then(res => {\n        this.ooxmlInfo.signatures = res.slice();\n      }).catch(() => {});\n\n    return sequence.then(() => this.ooxmlInfo);\n  }\n}\n"]}